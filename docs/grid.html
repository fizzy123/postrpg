<html>
  <head>
    <style>
      td {
        background: #222;
      }
      .contentTitle {
        background: #111;
        margin: 10px 20px;
        padding: 10px;
      }
      .selected {
        border: 1px white solid;
      }
      .content {
        padding: 20px;
      }
      .contentName {
        font-size: 24px;
      }
      input,textarea {
        width: 100%;
        background-color: black;
        color: white;
      }
      table {
        margin: auto;
      }
      .generate {
        margin: auto;
      }
      .highlight {
        border: 1px white solid;
      }
    </style>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Faker/3.1.0/faker.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
      let personToPersonRel = []
      let personToItemRel = []
      let personToFeatureRel = []
      let featureToItemRel = []
      let emotions = []
      let archetypes = []
      let features = []
      let events = []
      let reactions = []
      let entities = []
      let items = []
      let grid = [
        [[], [], []],
        [[], [], []],
        [[], [], []],
      ]
      let idCounter = 0
      let establishCorpus = async () => {
        // parse corpus sheet

        let sheetIndex = 7
        let response = await axios.get(`https://spreadsheets.google.com/feeds/list/1NXj5-cpQ7Cnn3fB-lKoRFCjJ0GTC34AULyHQF4zYek0/${sheetIndex}/public/values?alt=json`);
        for (const row of response.data.feed.entry) {
          if (row["gsx$persontopersonrel"]["$t"]) {
            personToPersonRel.push(row["gsx$persontopersonrel"]["$t"])
          }
          if (row["gsx$persontoitemrel"]["$t"]) {
            personToItemRel.push(row["gsx$persontoitemrel"]["$t"])
          }
          if (row["gsx$persontofeaturerel"]["$t"]) {
            personToFeatureRel.push(row["gsx$persontofeaturerel"]["$t"])
          }
          if (row["gsx$featuretoitemrel"]["$t"]) {
            featureToItemRel.push(row["gsx$featuretoitemrel"]["$t"])
          }
          if (row["gsx$emotions"]["$t"]) {
            emotions.push(row["gsx$emotions"]["$t"])
          }
          if (row["gsx$archetypes"]["$t"]) {
            archetypes.push(row["gsx$archetypes"]["$t"])
          }
          if (row["gsx$features"]["$t"]) {
            features.push({
              id: idCounter++,
              name: row["gsx$features"]["$t"],
              description: "",
              type:"feature",
            })
          }
          if (row["gsx$events"]["$t"]) {
            events.push(row["gsx$events"]["$t"])
          }
          if (row["gsx$reactions"]["$t"]) {
            reactions.push(row["gsx$reactions"]["$t"])
          }
        }
        // parse entity sheet
        sheetIndex = 8
        response = await axios.get(`https://spreadsheets.google.com/feeds/list/1NXj5-cpQ7Cnn3fB-lKoRFCjJ0GTC34AULyHQF4zYek0/${sheetIndex}/public/values?alt=json`);
        for (const row of response.data.feed.entry) {
          entities.push({
            id: idCounter++,
            name: row["gsx$name"]["$t"],
            description: row["gsx$description"]["$t"],
            type: "entity",
            emotion: emotions[Math.floor(Math.random() * emotions.length)],
          })
        }
        // parse items sheet
        sheetIndex = 9
        response = await axios.get(`https://spreadsheets.google.com/feeds/list/1NXj5-cpQ7Cnn3fB-lKoRFCjJ0GTC34AULyHQF4zYek0/${sheetIndex}/public/values?alt=json`);
        for (const row of response.data.feed.entry) {
          items.push({
            id: idCounter++,
            name: row["gsx$name"]["$t"],
            description: row["gsx$description"]["$t"],
            type: "item",
          })
        }
      }
      function shuffle(array) {
        var currentIndex = array.length, temporaryValue, randomIndex;
      
        // While there remain elements to shuffle...
        while (0 !== currentIndex) {
      
          // Pick a remaining element...
          randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex -= 1;
      
          // And swap it with the current element.
          temporaryValue = array[currentIndex];
          array[currentIndex] = array[randomIndex];
          array[randomIndex] = temporaryValue;
        }
      
        return array;
      }
			const rotate = function(nums, k) {
				if(nums.length > k){
					nums.unshift( ...nums.splice(-k))
				} else {
					let i = 0
					while(i < k){
						nums.unshift(nums.splice(-1))
						i++
					}
				}
				return nums

			};
      const generateMap = () => {
        grid = [
          [[], [], []],
          [[], [], []],
          [[], [], []],
        ]
        // select which magic items will exist
        items = shuffle(items)
        const itemSelection = items.slice(0,4)

        // generate characters that should exist
        const characters = []
        for (let index = 0; index < 3; index++) {
          characters.push({
            id: idCounter++,
            name: faker.name.findName(),
            description: `Archetype: ${archetypes[Math.floor(Math.random() * archetypes.length)]}\n`,
            type: "character",
          })
        }

        // choose which entities should be on the map
        entities = shuffle(entities)
        const entitySelection = entities.slice(0,5)

        // choose which features should be on a map
        features = shuffle(features)
        const featureSelection = features.slice(0,5)

        const subjects = [...characters];
        const predicates = rotate([...characters], 1);
        for (let i = 0; i < subjects.length; i++) {
          const subject = subjects[i]
          const predicate = predicates[i]
          if (subject.name === predicate.name) {
            continue
          }
          const event = events[Math.floor(Math.random() * events.length)]
          subject.description = `${subject.description}\n${subject.name} ${event} ${predicate.name}\nThey left the encounter feeling ${emotions[Math.floor(Math.random() * emotions.length)]}\n`
          predicate.description = `${predicate.description}\n${subject.name} ${event} ${predicate.name}\nThey left the encounter feeling ${emotions[Math.floor(Math.random() * emotions.length)]}\n`
        }

        for (let i = 0; i < characters.length; i++) {
          characters[i].description = `${characters[i].description}\nAs a result, they now ${reactions[Math.floor(Math.random() * reactions.length)]} someone/something.`
        }

        // assign characters, entities, features and items to cells
        const content = shuffle(characters).concat(shuffle(entitySelection)).concat(shuffle(featureSelection)).concat(shuffle(itemSelection))
        let positions = [0, 1, 2, 3, 4, 5, 6, 7, 8]
        positions = shuffle(positions).concat(shuffle(positions))
        for (let i = 0; i < content.length; i++) {
          grid[Math.floor(positions[i] / 3)][Math.floor(positions[i] % 3)].push(content[i])
          content[i].position = positions[i]
        }
        //// generate relationships and relationship details to characters, entities, and features
        //for (let index = 0; index < 2; index++) {
        //  const subjects = [...shuffle(content)]
        //  const predicates = [...shuffle(content)]
        //  for (let i = 0; i < subjects.length; i++) {
        //    const subject = subjects[i]
        //    const predicate = predicates[i]
        //    if (subject.name === predicate.name) {
        //      continue
        //    }

        //    let relationship
        //    if ((subject.type === "character" || subject.type === "entity") &&
        //        (predicate.type === "character" || predicate.type === "entity")) {
        //      relationship = {
        //        text: personToPersonRel[Math.floor(Math.random() * personToPersonRel.length)],
        //        subject: subject,
        //        predicate: predicate,
        //      }
        //    } else if ((subject.type === "character" && predicate.type === "item") ||
        //               (subject.type === "entity" && predicate.type === "item")) {
        //      relationship = {
        //        text: personToItemRel[Math.floor(Math.random() * personToItemRel.length)],
        //        subject: subject,
        //        predicate: predicate,
        //      }
        //    } else if ((subject.type === "item" && predicate.type === "character") ||
        //               (subject.type === "item" && predicate.type === "entity")) {
        //      relationship = {
        //        text: personToItemRel[Math.floor(Math.random() * personToItemRel.length)],
        //        subject: predicate,
        //        predicate: subject,
        //      }
        //    } else if ((subject.type === "character" && predicate.type === "feature") ||
        //               (subject.type === "entity" && predicate.type === "feature")) {
        //      relationship = {
        //        text: personToFeatureRel[Math.floor(Math.random() * personToFeatureRel.length)],
        //        subject: subject,
        //        predicate: predicate,
        //      }
        //    } else if ((subject.type === "feature" && predicate.type === "character") ||
        //               (subject.type === "feature" && predicate.type === "entity")) {
        //      relationship = {
        //        text: personToFeatureRel[Math.floor(Math.random() * personToFeatureRel.length)],
        //        subject: predicate,
        //        predicate: subject,
        //      }
        //    } else if (subject.type === "item" && predicate.type === "feature") {
        //      relationship = {
        //        text: featureToItemRel[Math.floor(Math.random() * featureToItemRel.length)],
        //        subject: predicate,
        //        predicate: subject,
        //      }
        //    } else if (subject.type === "feature" && predicate.type === "item") {
        //      relationship = {
        //        text: featureToItemRel[Math.floor(Math.random() * featureToItemRel.length)],
        //        subject: subject,
        //        predicate: predicate,
        //      }
        //    } else {
        //      console.log(subject.type)
        //      console.log(predicate.type)
        //      console.log("\n")
        //      continue
        //    }

        //    relationship.subject.description = `${relationship.subject.description}\n${relationship.subject.name} ${relationship.text} ${relationship.predicate.name}`.trim()
        //    relationship.predicate.description = `${relationship.predicate.description}\n${relationship.subject.name} ${relationship.text} ${relationship.predicate.name}`.trim()
        //  }
        //}
        window.localStorage.grid = JSON.stringify(grid)
        updateGrid()
        showContents($(".description").data("x"), $(".description").data("y"))
      }
      const createMapRepresentation = () => {
        // create table
        updateGrid()
        // create description
        const descriptionDiv = $("<div>")
        descriptionDiv.addClass("description")
        descriptionDiv.text = "Click on a cell to show more detailed information."
        $("body").append(descriptionDiv)
      }
      const showContents = (x, y) => {
        let contents = grid[x][y]
        $(".description").remove()
        const descriptionDiv = $("<div>")
        descriptionDiv.addClass("description")
        for (const content of contents) {
          contentDiv = $("<div>")
          contentDiv.addClass("content")
          contentDiv.data("id", content.id)

          nameInput = $("<input>")
          nameInput.addClass("contentName")
          nameInput.val(content.name)
          nameInput.keyup(updateContent)
          contentDiv.append(nameInput)

          contentDiv.append($("<br>"))

          descriptionInput = $("<textarea>")
          descriptionInput.addClass("contentDescription")
          descriptionInput.val(content.description)
          descriptionInput.keyup(updateContent)
          contentDiv.append(descriptionInput)         

          const removeContentDiv = $("<div>")
          removeContentDiv.text = "DELETE"
          removeContentDiv.click(removeContent)
          contentDiv.append(removeContentDiv)
          
          descriptionDiv.append(contentDiv)
        }
        const addContentDiv = $("<div>")
        addContentDiv.text = "+"
        addContentDiv.click(addContent)
        descriptionDiv.append(addContentDiv)
        descriptionDiv.data("x", x)
        descriptionDiv.data("y", y)
        console.log("description div")
        console.log(descriptionDiv)
        console.log("x", descriptionDiv.data("x"))
        console.log("y", descriptionDiv.data("y"))

        updateGrid();
        $(".cell" + x + "-" + y).addClass("highlight")
        $("body").append(descriptionDiv)
        $(".contentDescription").each(function() {
          $(this).css("height", "");
          $(this).css("height", $(this).prop("scrollHeight") + "px");
        })
      }
      const addContent = () => {
        const x = $(".description").data("x")
        const y = $(".description").data("y")
        grid[x][y].push({
          id: idCounter++
        })
        window.localStorage.grid = JSON.stringify(grid)
        updateGrid()
      }
      const removeContent = function() {
        const x = $(".description").data("x")
        const y = $(".description").data("y")
        const id = $(this).parents(".content")
        window.localStorage.grid = JSON.stringify(grid)
        updateGrid()
      }
      const updateContent = function() {
        $(this).css("height", "");
        $(this).css("height", $(this).prop("scrollHeight") + "px");
        // update state
        const x = $(this).parents(".description").data("x")
        const y = $(this).parents(".description").data("y")
        const id = $(this).parents(".content").data("id")
        console.log("update")
        console.log("x: ", x)
        console.log("y: ", y)
        const contents = grid[x][y]
        for (const content of contents) {
          if (content.id === id) {
            content[$(this).attr('class').slice(7).toLowerCase()] = $(this).val()
          }
        }
        window.localStorage.grid = JSON.stringify(grid)
        updateGrid()
      }
      const updateGrid = () => {
        $("table").remove()
        $(".generate").remove()

        const generateButton = $("<button>")
        generateButton.text("Generate")
        generateButton.click(generateMap)
        generateButton.addClass("generate")
        $("body").prepend(generateButton)

        const x = $(".description").data("x")
        const y = $(".description").data("y")

        const table = $("<table>")
        const tbody = $("<tbody>")
        
        for (let i = 0; i < 3; i++) {
          let tr = $("<tr>")
          for (let j = 0; j < 3; j++) {
            let td = $("<td>")
            td.data("x", i)
            td.data("y", j)
            td.addClass("cell" + i + "-" + j)
            let cellContents = grid[i][j]
            for (const content of cellContents) {
              let titleDiv = $("<div>")
              titleDiv.text(content.name)
              titleDiv.addClass("contentTitle")
              td.append(titleDiv)
            }
            td.click(function() {
              showContents($(this).data("x"), $(this).data("y"))
            })
            if (i === x && j === y) {
              td.addClass("selected")
            }
            tr.append(td)
          }
          tbody.append(tr)
        }
        table.append(tbody)
        $("body").prepend(table)
      }
      const init = async () => {
        await establishCorpus()
        if (!window.localStorage.grid) {
          generateMap()
        } else {
          grid = JSON.parse(window.localStorage.grid)
          updateGrid()
        }
        createMapRepresentation()
      }
      $( document ).ready(init)
    </script>
  </head>
  <body style="background-color:black;color:white;text-align: center;">
  </body>
</html>